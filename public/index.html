<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Planny HTML</title>
<style id="addon-terminal-minheight-v3">
  .card:first-of-type { display: none !important; }
  #terminal, .terminal, #console, .console, #log, .log {
    height: 140px !important;
    max-height: 140px !important;
    overflow-y: auto !important;
  }
  .ln.ln-cell{ background: transparent; padding: 0; margin: 2px 0; }
  .terminal .ln{ background: transparent !important; }
  .terminal .ln.ln-cell{ background: transparent !important; padding: 0; margin: 2px 0; }
#calendar {table-layout: fixed; width:100%; border-collapse: collapse;}
th.datecol, td.datecol {width:100px; min-width:100px; max-width:100px;}
td, th {padding: 2px 4px;}
#calendar-container {margin-left:0;margin-right:0;padding-left:4px;padding-right:4px;max-width:100%;}
#calendar {margin-left:0;margin-right:0;}
.wrap{max-width:100% !important;margin:0 !important;padding-left:6px !important;padding-right:6px !important;}
.card{padding-left:8px !important;padding-right:8px !important;}
.month{margin-top:8px;}
</style>
<style>
  :root{
    --bg:#f5f7fb; --panel:#ffffff; --surface:#eef2f7; --border:#dfe5ef;
    --text:#0f1720; --muted:#5b6877;
    --accent:#2563eb; --accent2:#16a34a; --warn:#d97706; --holiday:#166534;
    --chip:#f3f8ff; --chipBorder:#cfd9ea; --todayRow:rgba(34,197,94,.18);
    --nameHeaderBg:#e9f3ff; --nameColBg:#f8fbff;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
  h1{font-size:20px;margin:0 0 10px}
  .wrap{max-width:1280px;margin:0 auto;padding:16px}

  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px}
  .bar{display:grid;grid-template-columns:repeat(8,minmax(0,1fr));gap:8px;align-items:end}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="text"],input[type="number"]{width:100%;box-sizing:border-box;background:var(--surface);border:1px solid var(--border);color:var(--text);border-radius:10px;padding:10px}
  input[disabled]{opacity:.7}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#0e1724;border:1px solid var(--border);font-size:12px;color:#b9c6d8}
  .hint{font-size:12px;color:var(--muted)}

  .tabsbar{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-top:6px}
  .tabs{display:flex;gap:6px;flex-wrap:wrap}
  .tab{padding:8px 10px;border-radius:10px;background:var(--surface);border:1px solid var(--border);cursor:pointer;font-weight:600;color:#5b6877}
  .tab.active{background:var(--accent);color:#07121f;border-color:transparent}
  .bar-right{display:flex;gap:8px;align-items:center}
  .btn{appearance:none;border:1px solid var(--border);background:var(--surface);color:var(--text);padding:10px 12px;border-radius:10px;cursor:pointer}
  .btn.mini{padding:6px 10px;font-size:12px}
  .searchbox{display:flex;gap:6px;align-items:center}
  .searchbox input{width:220px;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:var(--surface)}
  .search-count{font-size:12px;color:var(--muted);min-width:60px;text-align:center}

  .month{margin-top:10px;max-height:68vh;overflow-y:auto;overscroll-behavior:contain;-webkit-overflow-scrolling:touch;position:relative;scroll-snap-type:y mandatory;scroll-padding-top:48px}
  table{width:100%;border-collapse:separate;border-spacing:0;position:relative;margin:0}
  #calendar tbody tr{scroll-snap-align:start}
  th,td{border:1px solid var(--border);padding:0}
  thead th{position:sticky;top:0;background:#eef3fa;z-index:5}
  th.name{min-width:110px;background:var(--nameHeaderBg)}
  th.small{width:70px}
  th.datecol{width:100px}
 td.datecol { width:100px; }

  td input{width:100%;box-sizing:border-box;border:0;background:transparent;color:var(--text);padding:8px;text-align:center;font:16px/1.2 "Segoe UI",system-ui}
  td input:focus{outline:2px solid var(--accent)}
  .rowhdr{background:var(--nameHeaderBg);color:#0f1720;text-align:right;padding:6px 8px;font-weight:700}
  .count{font-weight:700;text-align:center}

  .c-white{background:white}
  .c-yellow{background:yellow}
  .c-orange{background:orange}
  .c-red{background:red}

  .holiday{background:var(--holiday);color:#fff;font-weight:700}

  .cell{position:relative;height:40px;background:var(--nameColBg)}
  .cell.selected{outline:2px solid var(--accent); outline-offset:-2px;}
  .cell.search-hit{box-shadow: inset 0 0 0 3px #f59e0b;}

  .chip{
    position:absolute; inset:2px; display:flex; align-items:center; justify-content:center;
    border-radius:12px; border:1px solid var(--chipBorder); background:var(--chip);
    font-weight:700; cursor:grab; user-select:none; padding:0 16px; font-size:18px; 
    white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
  .chip:active{cursor:grabbing}
  .chip.ts1{color:#ef4444} .chip.ts2{color:#3b82f6}
  .chip.att{color:#f59e0b} .chip.training{color:#0ea5e9} .chip.rec{color:#8b5cf6}
  .chip.holiday{background:var(--holiday); color:#fff}
  .chip.hidden{display:none}

  .droptarget{outline:2px dashed #3aa0ff; outline-offset:-3px}
  .dragging{opacity:.8; transform:scale(0.99)}
  .hidden{display:none}

  .cell.editing .chip{ display:none !important; }
  .cell.editing input{ display:block !important; }

  tr.today td:not(.count){ background: var(--todayRow); }
  tr.today .rowhdr{ color:#0f1720; }

  .terminal{
    background:#0b0b0b;border:1px solid var(--border);border-radius:14px;padding:10px;color:#c7d1db;
    font:12px/1.4 ui-monospace,SFMono-Regular,Consolas,Monaco,monospace;height:220px;overflow-y:auto;overflow-x:hidden;word-break:break-word;
  }
  .ln{white-space:pre-wrap;margin:2px 0}
  .ln.info{color:#9bb0c9} .ln.ok{color:#16a34a} .ln.warn{color:#f59e0b} .ln.err{color:#ef4444}

  /* Context menu */
  .ctx{position:fixed; z-index:9999; background:#10151c; color:#e2e8f0; border:1px solid #2a3441; border-radius:10px; box-shadow:0 12px 28px rgba(0,0,0,.35); padding:6px; min-width:180px; display:none}
  .ctx .itm{padding:8px 10px; border-radius:8px; cursor:pointer; user-select:none}
  .ctx .itm:hover,.ctx .itm:focus{background:#1b2532; outline:none}
  .ctx .sep{height:1px; background:#233042; margin:6px 4px}
  .ln.ln-cell{ background: transparent; padding: 0; margin: 2px 0; }
  .terminal .ln{ background: transparent !important; }
  .terminal .ln.ln-cell{ background: transparent !important; padding: 0; margin: 2px 0; }
#calendar {table-layout: fixed; width:100%; border-collapse: collapse;}
th.datecol, td.datecol {width:100px; min-width:100px; max-width:100px;}
td, th {padding: 2px 4px;}
#calendar-container {margin-left:0;margin-right:0;padding-left:4px;padding-right:4px;max-width:100%;}
#calendar {margin-left:0;margin-right:0;}
</style>
</head>
<body>
<div class="wrap">
  
<div id="auth-bar" style="display:flex;gap:.5rem;align-items:center;justify-content:flex-end;padding:.5rem 1rem;border-bottom:1px solid #eee;margin-bottom:8px">
  <span id="auth-status">ðŸ‘¤ ospite</span>
  <button id="btn-login">Login</button>
  <button id="btn-logout" style="display:none">Logout</button>
</div>

  <div class="card" style="margin-top:10px">
    <div class="tabsbar">
      <div class="tabs" id="tabs"></div>
      <div class="bar-right">
        <div class="searchbox">
          <input id="search-q" type="text" placeholder="Cerca impegnoâ€¦" />
          <button id="search-prev" class="btn mini" title="Precedente">Prev</button>
          <button id="search-next" class="btn mini" title="Successivo">Next</button>
          <div id="search-count" class="search-count">0/0</div>
        </div>
        <button id="jump-today" class="btn mini" title="Vai a oggi">Oggi</button>
      </div>
    </div>
    <div id="month" class="month">
      <table id="calendar">
        <thead id="thead"></thead>
      </table>
    </div>
  </div>

  <div class="card" style="margin-top:10px">
    <h2 style="margin:0 0 8px;font-size:14px;color:#9bb0c9">Terminale</h2>
    <div id="terminal" class="terminal" aria-live="polite" aria-atomic="false"></div>
  </div>
</div>

<!-- Context menu -->
<div id="ctx" class="ctx" role="menu" aria-hidden="true">
  <div class="itm" data-cmd="copy" tabindex="0">Copia</div>
  <div class="itm" data-cmd="paste" tabindex="0">Incolla</div>
  <div class="sep"></div>
  <div class="itm" data-cmd="clear" tabindex="0">Cancella</div>
</div>

<datalist id="options-list"></datalist>

<script>
(function(){
  /* ------- Logger ------- */
window.logBuffer = (window.logBuffer ?? []);     // unico buffer globale
function log(msg, type='info'){
  (type==='err'?console.error:type==='warn'?console.warn:console.log)(msg);
  if(type !== 'cell') return;
  const t = document.getElementById('terminal');
  const ts = new Date().toLocaleTimeString();
  const text = '['+ts+'] '+msg;
  window.logBuffer.push(text);                   // scrive sempre nel globale
  if(t){
    const line = document.createElement('div');
    line.className='ln ln-cell';
    line.textContent=text;
    t.appendChild(line);
    t.scrollTop = t.scrollHeight;
  }
}
  // Azioni strutturate sui chip/celle
  function logAction(action, date, name, value, extra){
    const line = `${action} ${date}, ${name}${value!==undefined && value!==''?','+value:''}${extra? ' '+extra: ''}`;
    log(line,'cell');
  }
  window.addEventListener('error', ev=>log('JS error: '+ev.message,'err'));
  window.addEventListener('unhandledrejection', ev=>log('Promise: '+(ev.reason?.message||ev.reason),'err'));

  /* ------- Stato ------- */
  const state = {
    year: new Date().getFullYear(),
    names: [], options: [],
    selections: new Map(),
    columnOrder: null, holidays: new Set(),
    stackTop:null, stackBottom:null, stackCenter:null,
    anchorCell: null, selected: new Set(),
    clipboard: null,
    ctxTarget: null,
    search: {q:'', hits:[], idx:-1}
  };
  // Espongo lo state per script esterni (year_single_selector.js)
  window.state = state;
  state.deletions = new Set();
  const save = { selName:'', logName:'' };

  const $=s=>document.querySelector(s);
  const months=["Gen","Feb","Mar","Apr","Mag","Giu","Lug","Ago","Set","Ott","Nov","Dic"];
  const pad=n=>(n<10?"0":"")+n;
  const fmt=d=>pad(d.getDate())+"-"+pad(d.getMonth()+1)+"-"+d.getFullYear();
  const cssEscape = (s)=> (window.CSS && CSS.escape ? CSS.escape(s) : s.replace(/[^a-zA-Z0-9_-]/g, ch => '\\'+ch));

  /* ------- Suggestions (prefix-based) ------- */
  const suggest = {
    box: null, items: [], index: -1, input: null,
    ensureBox(){
      if(this.box) return this.box;
      const el = document.createElement('div'); el.className='sugg'; el.id='suggestions';
      // style inline to avoid missing CSS in refactor
      el.style.position='fixed'; el.style.zIndex='10000'; el.style.background='#fff'; el.style.border='1px solid var(--border)';
      el.style.borderRadius='10px'; el.style.boxShadow='0 10px 24px rgba(0,0,0,.15)'; el.style.padding='4px'; el.style.display='none';
      el.style.maxHeight='240px'; el.style.overflow='auto'; el.style.minWidth='140px';
      document.body.appendChild(el);
      this.box = el;
      el.addEventListener('mousedown', (e)=>{
        const it = e.target.closest('.it'); if(!it) return;
        e.preventDefault();
        const idx = Array.from(this.box.querySelectorAll('.it')).indexOf(it);
        this.apply(idx);
      });
      return el;
    },
    open(input){
      this.ensureBox();
      this.input = input; this.index = -1;
      this.update();
      this.position();
      this.box.style.display = (this.items.length? 'block':'none');
    },
    close(){ if(this.box){ this.box.style.display='none'; } this.input=null; this.index=-1; this.items=[]; },
    position(){
      if(!this.input || !this.box) return;
      const r = this.input.getBoundingClientRect();
      this.box.style.left = Math.round(r.left) + 'px';
      this.box.style.top  = Math.round(r.bottom + 4) + 'px';
      this.box.style.minWidth = Math.max(140, Math.round(r.width)) + 'px';
    },
    update(){
      if(!this.input) return;
      const q = (this.input.value||'').trim().toLowerCase();
      if(!q){ this.items=[]; this.render(); return; }
      const opts = (state.options||[]).slice();
      const pref = opts.filter(o=> (o||'').toLowerCase().startsWith(q));
      this.items = pref.slice(0, 20);
      this.render();
    },
    render(){
      if(!this.box) return;
      this.box.innerHTML = this.items.map((t,i)=>`<div class="it${i===this.index?' active':''}" style="padding:8px 10px;border-radius:8px;cursor:pointer;white-space:nowrap">${t}</div>`).join('');
    },
    move(delta){
      if(!this.items.length){ this.index=-1; this.render(); return; }
      this.index = ( (this.index + delta) % this.items.length + this.items.length ) % this.items.length;
      this.render();
    },
    apply(idx=null){
      if(idx==null) idx=this.index;
      if(idx<0 || idx>=this.items.length || !this.input) return;
      const val = this.items[idx];
      this.input.value = val;
      const p=this.input.dataset.date.split('-'); const d=new Date(+p[2], +p[1]-1, +p[0]);
      styleCell(this.input, val, d);
      this.close();
      setTimeout(()=>{ this.input.focus(); this.input.selectionStart=this.input.selectionEnd=this.input.value.length; },0);
    }
  };
  window.addEventListener('resize', ()=> suggest.position());
  window.addEventListener('scroll', ()=> suggest.position(), true);

  /* ------- Helpers fetch/file ------- */
  
  window.__SINGLE_IMPORTER = "importSelectionsFromText";
  
  // Espongo importer selections per year_single_selector.js
  window.__fileVersion = window.__fileVersion || {};

async function putTextToServer(filename, text, {timeoutMs=15000} = {}){
  const ctrl = new AbortController();
  const to = setTimeout(()=>ctrl.abort('timeout'), timeoutMs);
  try{
    const res = await guardedFetch(`/api/files/public/${filename}`, {
      method: 'PUT',
      headers: {'Content-Type':'text/plain; charset=utf-8'},
      body: text,
      cache: 'no-store',
      signal: ctrl.signal
    });
    const body = await res.text().catch(()=> '');
    if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} ${body ? '- '+body : ''}`);
    window.__fileVersion[filename] = Date.now();
    return body;
  } finally { clearTimeout(to); }
}

  async function getTextFromServer(filename){
  const ver = window.__fileVersion?.[filename] || Date.now();
  const url = `/api/files/public/${filename}?v=${ver}`;
  const res = await fetch(url, {
    cache: 'no-store',
    headers: {
      'Cache-Control': 'no-cache, no-store, max-age=0, must-revalidate',
      'Pragma': 'no-cache'
    }
  });
  if(!res.ok) throw new Error('HTTP '+res.status);
  return res.text();
}


  /* ------- Parser INI & colonne ------- */
  function parseIni(text){
    const out={}; let section=null;
    text.split(/\r?\n/).forEach(raw=>{
      const line=raw.trim(); if(!line || line.startsWith(';') || line.startsWith('#')) return;
      const m=line.match(/^\[(.+?)\]$/);
      if(m){ section=m[1]; out[section]=out[section]||{}; return; }
      const kv=line.split('='); if(kv.length>=2){ const k=kv.shift().trim(); const v=kv.join('=').trim().replace(/^"|"$/g,''); (section?out[section]:out)[k]=v; }
    });
    return out;
  }
  function parseTabellaIni(text){
    return text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean).filter(x=>x.toLowerCase()!=='data');
  }
  function getColumns(){ return state.names || []; }

  /* ------- Log ------- */

function logsChunkSinceCursor(){
  if (window.logFlushCursor >= window.logBuffer.length) return '';
  const chunk = window.logBuffer.slice(window.logFlushCursor).join('\n') + '\n';
  window.logFlushCursor = window.logBuffer.length;
  return chunk;
}

async function appendLogsToServer(opts={force:false}){
	if (!window.__canWrite) {
    log('Permessi insufficienti: effettua il login come admin per salvare.', 'warn');
    return;
  }
  const year = state.year;
  const name = `planny_log_${year}.txt`;

  let chunk = logsChunkSinceCursor();
  if (!chunk && opts.force){
    chunk = `[${new Date().toLocaleString()}] Sessione avviata su ${location.href}\n`;
  }
  if (!chunk) return;

  const taskId = `log:${name}:${Date.now()}`;
  __SaveTracker.start(taskId);

  try{
    // 1) leggi dallo SCHEMA server (cache-buster giÃ  in getTextFromServer)
    const serverText = await getTextFromServer(name).catch(()=> '');
    // 2) append e normalizza
    const merged = (serverText + chunk).replace(/\r\n/g,'\n');
    // 3) scrivi su server
    await putTextToServer(name, merged);
    log('Log aggiornato (PUT) su server: '+name, 'ok');
    __SaveTracker.ok(taskId);
  }catch(err){
    __SaveTracker.fail(taskId, err);
    throw err; // nessun fallback locale
  }
}


  /* ------- Config helpers ------- */
  function parseYearFromConfigTxt(text){
    let year=null;
    text.split(/\r?\n/).forEach(line=>{
      const t=line.trim();
      if(!t || t.startsWith('#') || t.startsWith('//')) return;
      const m = t.match(/^\s*(ANNO|YEAR|ANNO_CALENDARIO)\s*[:=]\s*(\d{4})\s*$/i);
      if(m){ year = parseInt(m[2],10); }
    });
    return year;
  }

  /* ------- Selections (file) ------- */
  function selectionsFileName(){ return `selections_${state.year}.txt`; }
  function selectionsToText(){
    const entries=[...state.selections.entries()].map(([k,v])=>({k,v,del:false}));
    const dels=[...state.deletions].map(k=>({k,v:'__DEL__',del:true}));
    const all = entries.concat(dels);
    all.sort((a,b)=>{
      const [ad,an]=a.k.split(','),[bd,bn]=b.k.split(',');
      const pa=ad.split('-').reverse().join(''), pb=bd.split('-').reverse().join('');
      const s = pa!==pb?pa.localeCompare(pb):an.localeCompare(bn);
      if(s!==0) return s;
      // A paritÃ  di chiave, scrivi prima i valori poi le DEL? Meglio DEL dopo per prevalere.
      return (a.del===b.del)?0:(a.del?1:-1);
    });
    return all.map(o=>o.k+','+o.v).join('\n')+'\n';
  }
  function normSelectionsText(s){
  return String(s||'')
    .replace(/\r\n/g, '\n')
    .replace(/[ \t]+$/gm, '')
    .trim();
}

async function saveSelectionsToServer(){
	if (!window.__canWrite) {
    log('Permessi insufficienti: effettua il login come admin per salvare.', 'warn');
    return;
  }
  const name = selectionsFileName();
  if (__saveInFlight){ __saveQueued = true; return; }
  __saveInFlight = true;
  const taskId = `selections:${name}:${Date.now()}`;
  __SaveTracker.start(taskId);
  try{
    const text = normSelectionsText(selectionsToText()) + '\n';
    await putTextToServer(name, text);
    log('Selections salvati su server: '+name, 'ok');
    __SaveTracker.ok(taskId);
  }catch(err){
    __SaveTracker.fail(taskId, err);
    throw err; // niente fallback: fallisce visibilmente
  }finally{
    __saveInFlight = false;
    if (__saveQueued){ __saveQueued = false; scheduleAutoSave(300); }
  }
}


  /* ------- FestivitÃ  ------- */
  async function loadHolidaysFromLocalOrWeb(){
  const fname = `festivi_${state.year}.txt`;
  const txt = await getTextFromServer(fname); // ðŸ‘ˆ nessun fallback a fetchText

  const set = new Set();
  txt.split(/\r?\n/).forEach(line=>{
    const t=line.trim();
    if(!t || t.startsWith('#')) return;
    if(/^\d{2}-\d{2}-\d{4}$/.test(t)) set.add(t);
  });
  state.holidays = set;
  log(`Festivi caricati da ${fname}: ${set.size} date`,'ok');
}

  function easterDate(y){
    const a = y % 19, b = Math.floor(y / 100), c = y % 100, d = Math.floor(b / 4), e = b % 4;
    const f = Math.floor((b + 8) / 25), g = Math.floor((b - f + 1) / 3);
    const h = (19 * a + b - d - g + 15) % 30;
    const i = Math.floor(c / 4), k = c % 4;
    const l = (32 + 2 * e + 2 * i - h - k) % 7;
    const m = Math.floor((a + 11 * h + 22 * l) / 451);
    const month = Math.floor((h + l - 7 * m + 114) / 31);
    const day = ((h + l - 7 * m + 114) % 31) + 1;
    return new Date(y, month - 1, day);
  }
  function italianHolidays(year){
    const set = new Set();
    const pad = n => (n<10?'0':'') + n;
    const add = (d) => set.add(pad(d.getDate()) + '-' + pad(d.getMonth()+1) + '-' + d.getFullYear());
    [[1,1],[1,6],[4,25],[5,1],[6,2],[8,15],[11,1],[12,8],[12,25],[12,26]].forEach(([m, d])=>{
      add(new Date(year, m-1, d));
    });
    const easter = easterDate(year);
    const easterMon = new Date(easter); easterMon.setDate(easter.getDate()+1);
    add(easterMon);
    return set;
  }
  async function saveFestiviToServer(year, lines){
  const name = `festivi_${year}.txt`;
  const payload = lines.join('\n') + '\n';
  const res = await guardedFetch(`/api/files/public/${encodeURIComponent(name)}`, {
    method: 'PUT',
    headers: {'Content-Type':'text/plain;charset=utf-8'},
    body: payload,
    cache: 'no-store'
  });
  if(!res.ok) return; // alert giÃ  mostrato da guardedFetch su 401/403
  log('Festivi salvati su server: ' + name, 'ok');
}



  // Espongo importer selections per year_single_selector.js
  
  // Espongo per script esterni
  window.loadHolidaysFromLocalOrWeb = loadHolidaysFromLocalOrWeb;

  /* ------- Import selections (parsing) ------- */
  function importSelectionsFromText(txt){

    txt = (typeof txt === 'string') ? txt : (window.__singleSelectionsText || '');
    if (!txt) { try{ console.debug('importSelectionsFromText: empty payload, skip'); }catch(_){ } return; }
    try{ var __digest = 'len:' + txt.length + '|head:' + txt.slice(0,64) + '|tail:' + txt.slice(-64); if (window.__lastSelectionsDigest === __digest) { return; } window.__lastSelectionsDigest = __digest; }catch(_){}

    const map=new Map(); let n=0; const yearCount = {};
    txt.split(/\r?\n/).forEach(line=>{
      const t=line.trim(); if(!t) return;
      const parts=t.split(','); if(parts.length<3) return;
      const date=parts[0].trim(), name=parts[1].trim(), value=parts.slice(2).join(',').trim();
      const y = parseInt(date.split('-')[2],10); if(!isNaN(y)) yearCount[y]=(yearCount[y]||0)+1;
      const key = `${date},${name}`;
      if(value==='__DEL__' || value==='DEL' || value==='__DELETE__'){
        map.delete(key);
      }else{
        map.set(key, value);
      }
      n++;
    });
    state.selections=map; state.deletions = new Set();
    log(`Selections caricati: ${n} righe`,'ok');
    let yBest=null, cBest=0; for(const y in yearCount){ if(yearCount[y]>cBest){ cBest=yearCount[y]; yBest=parseInt(y,10);} }
    if(yBest && yBest!==state.year){
      state.year = yBest;
      const yearInput=$('#year'); if(yearInput) yearInput.value=state.year;
      log('Anno planner riallineato ai selections: '+state.year,'ok');
      loadHolidaysFromLocalOrWeb().then(()=>{
        const m = (new Date().getFullYear()===state.year)?(new Date().getMonth()+1):1;
        renderStack(m);
      });
    }
  }

  // Espongo importer selections per year_single_selector.js
  

  /* ------- Editing / Commit ------- */
  function enterEdit(td, initialChar=null){
  td.classList.add('editing');
  const input = td.querySelector('input'), chip = td.querySelector('.chip');
  chip.classList.add('hidden'); input.classList.remove('hidden');
  input.dataset.orig = input.value;

  setTimeout(()=>{
    input.focus();
    if (initialChar != null) {
      // avvio da tastiera: imposta il primo carattere e metti il cursore in coda
      input.value = initialChar;
      try { input.setSelectionRange(input.value.length, input.value.length); } catch(_){}
    } else {
      // avvio da mouse (dblclick, ecc.): seleziona tutto
      try { input.select(); } catch(_){}
    }
    suggest.open(input);
  }, 0);
}
  function onCellCommit(input){
    // delega a writeCell per garantire logging unico
    const td = input.closest('td.cell');
    const val = (input.value || '').trim();
    writeCell(td, val);
    if(state.search.q) buildSearchHits(state.search.q);
  }
  function exitEdit(td, saveIt){
    const input=td.querySelector('input'); if(!input)return;
    if(saveIt){ onCellCommit(input); } else { input.value=input.dataset.orig||input.value; }
    td.classList.remove('editing');
    syncChip(td);
    if(saveIt){ scheduleAutoSave(); }
  }

  function styleToken(val){
    const lo=(val||'').toLowerCase();
    if(val==='TS1')return'ts1';
    if(val==='TS2')return'ts2';
    if(['ferie','par','assente','permesso','malattia','meeting','trasferta'].includes(lo))return'att';
    if(lo==='training')return'training';
    if(val==='REC FERIE')return'rec';
    return'';
  }
  function isHolidayOrWeekend(d){return [6,0].includes(d.getDay()) || state.holidays.has(fmt(d))}

  function writeCell(td, val){
    // logging per-cella centralizzato: usa lo stato come 'prev'
    const key = td.dataset.key;
    const prevVal = (state.selections.get(key) || '').trim();
    const input = td.querySelector('input');
    input.value = (val||'');
    const p = td.dataset.date.split('-');
    const d = new Date(+p[2], +p[1]-1, +p[0]);
    if(val) state.selections.set(key, val); else state.selections.delete(key);
    const date = td.dataset.date; const name = td.dataset.name;
    if(prevVal && !val){ state.deletions.add(key); logAction('DELETE', date, name, prevVal); }
    else if(!prevVal && val){ if(state.deletions.has(key)) state.deletions.delete(key); logAction('SET', date, name, val); }
    else if(prevVal && val && prevVal!==val){ if(state.deletions.has(key)) state.deletions.delete(key); logAction('UPDATE', date, name, `${prevVal} -> ${val}`); }
    styleCell(input, val, d);
    syncChip(td);
    updateRowCount(td.closest('tr'));
  }

  // Chiudi tutte le celle in editing tranne (eventualmente) una
function closeAllEditingExcept(skipTd){
  document.querySelectorAll('td.cell.editing').forEach(el => {
    if(el !== skipTd){
      try { exitEdit(el, true); } catch(_){ /* ignore */ }
    }
  });
}

function makeCell(date,name){
    const td=document.createElement('td'); td.className='cell'; td.dataset.date=fmt(date); td.dataset.name=name; td.dataset.key=td.dataset.date+','+name;
    const input=document.createElement('input'); input.dataset.key=td.dataset.key; input.dataset.date=td.dataset.date; input.dataset.name=name;
    const chip=document.createElement('div'); chip.className='chip hidden'; chip.draggable=true;

    /* --- Gestione selezione --- */
    td.addEventListener('mousedown', (e)=>{ closeAllEditingExcept(td);
      if(e.button!==0) return;
      if(e.target.closest('.chip')) return;
      selectionHandleMouse(td, e);
    });

    td.addEventListener('dblclick', (e)=>{ 
      if(e.target.closest('.chip')) return; 
      e.preventDefault(); e.stopPropagation(); 
      enterEdit(td); 
    });
    chip.addEventListener('dblclick', e=>{e.preventDefault(); e.stopPropagation(); enterEdit(td);});
    chip.addEventListener('click', (e)=>{ if (window.matchMedia('(pointer: coarse)').matches) { e.preventDefault(); e.stopPropagation(); enterEdit(td); }});

    input.addEventListener('focus', () => { input.dataset.orig = input.value; td.classList.add('editing'); });
    input.addEventListener('keydown', e=>{
      if(e.key==='ArrowDown'){ e.preventDefault(); suggest.move(+1); return; }
      if(e.key==='ArrowUp'){ e.preventDefault(); suggest.move(-1); return; }
      if(e.key==='Tab'){ if(suggest.items.length){ e.preventDefault(); suggest.apply(); } return; }
      if(e.key==='Enter'){
        if(suggest.items.length){ e.preventDefault(); suggest.apply(); exitEdit(td,true); }
        else { e.preventDefault(); exitEdit(td,true); }
        return;
      }
      if(e.key==='Escape'){ e.preventDefault(); suggest.close(); exitEdit(td,false); return; }
    });
    input.addEventListener('blur', ()=>{ suggest.close(); exitEdit(td,true); });
    input.addEventListener('input', ()=>{
      const p=input.dataset.date.split('-'); const d=new Date(+p[2], +p[1]-1, +p[0]);
      styleCell(input,(input.value||'').trim(),d);
      suggest.open(input);
    });

    td.addEventListener('dragover', e=>{ e.preventDefault(); td.classList.add('droptarget'); });
    td.addEventListener('dragleave', ()=> td.classList.remove('droptarget'));
    td.addEventListener('drop', e=>{
      e.preventDefault(); td.classList.remove('droptarget');
      const payload=e.dataTransfer.getData('application/x-planny'); if(!payload) return;
      let data=null; try{data=JSON.parse(payload);}catch(_){}
      if(!data) return;
      const fromKey=data.fromKey, value=data.value, toKey=td.dataset.key;
      if(fromKey===toKey) return;
      const prev=state.selections.get(toKey)||'';
      if(e.shiftKey && prev){
        state.selections.set(fromKey, prev);
        state.selections.set(toKey, value);
        const [fDate,fName] = fromKey.split(',');
        const [tDate,tName] = toKey.split(',');
        logAction('SWAP', fDate, fName, value, `â‡„ ${tDate}, ${tName},${prev}`);
        refreshCellByKey(fromKey); refreshCellByKey(toKey);
      }else{
        state.selections.delete(fromKey);
        if(value) state.selections.set(toKey, value);
        const [fDate,fName] = fromKey.split(',');
        const [tDate,tName] = toKey.split(',');
        logAction('MOVE', fDate, fName, value, `â†’ ${tDate}, ${tName}${prev? ',(overwrite '+prev+')':''}`);
        refreshCellByKey(fromKey); refreshCellByKey(toKey);
      }
      scheduleAutoSave();
    });

    chip.addEventListener('dragstart', e=>{
      chip.classList.add('dragging');
      const key=td.dataset.key;
      let value=state.selections.get(key); if(value==null) value=(input.value||'').trim();
      e.dataTransfer.setData('application/x-planny', JSON.stringify({fromKey:key, value}));
      e.dataTransfer.setData('text/plain', value); e.dataTransfer.effectAllowed='move';
    });
    chip.addEventListener('dragend', ()=> chip.classList.remove('dragging'));

    td.appendChild(input); td.appendChild(chip); return td;
  }

  function syncChip(td){
    const input=td.querySelector('input'), chip=td.querySelector('.chip');
    const val=(input.value||'').trim();
    if(td.classList.contains('editing')){ chip.classList.add('hidden'); input.classList.remove('hidden'); return; }
    if(val){
      chip.textContent=val;
      chip.title = val;
      let klass='chip '+styleToken(val);
      const parts=td.dataset.date.split('-'); const d=new Date(+parts[2], +parts[1]-1, +parts[0]);
      if(isHolidayOrWeekend(d)) klass+=' holiday';
      chip.className=klass; chip.classList.remove('hidden'); input.classList.add('hidden');
    }else{
      chip.removeAttribute('title');
      chip.textContent=''; chip.className='chip hidden'; input.classList.remove('hidden');
    }
  }

  // Espongo importer selections per year_single_selector.js
  function refreshCellByKey(key){
    const td=document.querySelector('td.cell[data-key="'+cssEscape(key)+'"]'); if(!td) return;
    const input=td.querySelector('input'); input.value=state.selections.get(key)||'';
    const p=td.dataset.date.split('-'); const d=new Date(+p[2], +p[1]-1, +p[0]);
    styleCell(input,input.value,d); syncChip(td); updateRowCount(td.closest('tr'));
  }
  function updateRowCount(tr){
    const inputs=[...tr.querySelectorAll('input')];
    const filled=inputs.reduce((a,i)=>a+(i.value.trim()?1:0),0);
    const total=inputs.length;
    const tdCount=tr.querySelector('.count');
    tdCount.textContent=filled; tdCount.className='count '+countClass(filled,total);
  }

  /* ------- Header / mesi (scroll continuo) ------- */
  function updateScrollSnapPadding(){
    const c=document.querySelector('#month'); const thead=document.querySelector('#thead');
    if(!c || !thead) return;
    const h = Math.round(thead.getBoundingClientRect().height) || 0;
    c.style.scrollPaddingTop = h + 'px';
  }
  function buildHeader(){
    updateScrollSnapPadding();
    const names=getColumns();
    const thead = document.getElementById('thead');
    thead.innerHTML='';
    const hr=document.createElement('tr');
    const thD=document.createElement('th'); thD.className='datecol'; thD.textContent='Data'; hr.appendChild(thD);
    names.forEach(n=>{ const th=document.createElement('th'); th.className='name'; th.textContent=n; hr.appendChild(th); });
    const thC=document.createElement('th'); thC.className='small'; thC.textContent=' '; hr.appendChild(thC);
    thead.appendChild(hr);
  }
  function daysInMonth(y,m){ return new Date(y, m, 0).getDate(); }
  function makeMonthSection(m){
    const y=state.year, names=getColumns();
    const tbody=document.createElement('tbody'); tbody.dataset.m=m;
    const days=daysInMonth(y,m);
    for(let d=1; d<=days; d++){
      const tr=document.createElement('tr'); const dateObj=new Date(y, m-1, d); tr.dataset.date=fmt(dateObj);
      const dow=['Dom','Lun','Mar','Mer','Gio','Ven','Sab'][dateObj.getDay()];
	  const mon = months[m-1];  // mese abbreviato
      const tdDate=document.createElement('td');
        tdDate.classList.add('datecol'); tdDate.innerHTML='<div class="rowhdr">'+mon+' '+dow+' '+pad(d)+'</div>'; tr.appendChild(tdDate);

      let filled=0;
      names.forEach(name=>{
        const td=makeCell(dateObj,name), input=td.querySelector('input'), key=td.dataset.key, val=state.selections.get(key)||'';
        if(val){ input.value=val; filled++; }
        styleCell(input,input.value,dateObj); syncChip(td); tr.appendChild(td);
      });

      const tdCount=document.createElement('td'); tdCount.className='count '+countClass(filled,names.length); tdCount.textContent=filled; tr.appendChild(tdCount);
      tbody.appendChild(tr);
    }
    return tbody;
  }
  function countClass(n,t){const q3=(3*t)/4,h=t/2,q=t/4;return n>q3?'c-red':n>h?'c-orange':n>q?'c-yellow':'c-white'}
  function setActiveTab(m){
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    const btn=document.querySelector('.tab[data-m="'+m+'"]'); if(btn) btn.classList.add('active');
    state.stackCenter = m;
  }
  let flipping=false;
  function renderStack(centerMonth){
    const table = document.getElementById('calendar');
    const c=$('#month');
    const prevScroll = c.scrollTop;
    buildHeader();
    table.querySelectorAll('tbody').forEach(tb=>tb.remove());
    const start = Math.max(1, centerMonth-1);
    const end   = Math.min(12, centerMonth+1);
    let targetSection=null;
    for(let m=start; m<=end; m++){
      const sec = makeMonthSection(m);
      table.appendChild(sec);
      if(m===centerMonth) targetSection=sec;
    }
    state.stackTop = start; state.stackBottom = end; state.stackCenter = centerMonth;
    setActiveTab(centerMonth);
    updateScrollSnapPadding();
    if(targetSection){ c.scrollTop = targetSection.offsetTop; }
    else { c.scrollTop = prevScroll; }
  }
  function ensurePrevMonth(){
    if(state.stackTop <= 1) return;
    const table = document.getElementById('calendar');
    const c=$('#month');
    const newM = state.stackTop - 1;
    const sec = makeMonthSection(newM);
    table.insertBefore(sec, table.querySelector('tbody'));
    const added = sec.offsetHeight;
    c.scrollTop += added;
    updateScrollSnapPadding();
    state.stackTop = newM;
  }
  function ensureNextMonth(){
    if(state.stackBottom >= 12) return;
    const table = document.getElementById('calendar');
    const newM = state.stackBottom + 1;
    const sec = makeMonthSection(newM);
    table.appendChild(sec);
    state.stackBottom = newM;
    updateScrollSnapPadding();
  }
  function monthNearestCenter(){
    const c=$('#month'); const cRect=c.getBoundingClientRect(); const centerY = cRect.top + c.clientHeight/2;
    let bestM=null, bestDist=Infinity;
    document.querySelectorAll('#calendar tbody[data-m]').forEach(sec=>{
      const r=sec.getBoundingClientRect(); const mid=r.top + r.height/2;
      const dist=Math.abs(mid - centerY);
      if(dist<bestDist){ bestDist=dist; bestM=parseInt(sec.dataset.m,10); }
    });
    return bestM||state.stackCenter||1;
  }
  function setupScrollHandlers(){
    window.addEventListener('resize', updateScrollSnapPadding);
    const c=$('#month'); if(!c) return;
    c.addEventListener('scroll', (e)=>{
      if(flipping) return;
      const el=e.target;
      const atTop = el.scrollTop <= 6;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 6;

      if(atTop && state.stackTop>1){
        flipping=true; ensurePrevMonth(); setTimeout(()=>flipping=false, 50);
      }else if(atBottom && state.stackBottom<12){
        flipping=true; ensureNextMonth(); setTimeout(()=>flipping=false, 50);
      }

      const m = monthNearestCenter();
      if(m !== state.stackCenter){ setActiveTab(m); }
    }, {passive:true});
  }

  /* ------- Stile celle ------- */
  function styleCell(input,val,date){
    input.classList.remove('holiday'); input.style.color=''; input.style.fontWeight=''; input.style.fontSize='';
    if([6,0].includes(date.getDay()) || state.holidays.has(fmt(date))) input.classList.add('holiday');
    const lo=(val||'').toLowerCase();
    if(val==='TS1'){ input.style.color='#ef4444'; input.style.fontWeight='700'; input.style.fontSize='18px'; }
    else if(val==='TS2'){ input.style.color='#3b82f6'; input.style.fontWeight='700'; input.style.fontSize='18px'; }
    else if(['ferie','par','assente','permesso','malattia','meeting','trasferta'].includes(lo)){ input.style.color='#f59e0b'; input.style.fontWeight='700'; input.style.fontSize='18px'; }
    else if(lo==='training'){ input.style.color='#0ea5e9'; input.style.fontWeight='700'; input.style.fontSize='18px'; }
    else if(val==='REC FERIE'){ input.style.color='#8b5cf6'; input.style.fontWeight='700'; input.style.fontSize='18px'; }
  }


  // Espongo importer selections per year_single_selector.js

  /* ------- Year Change Glue (per script esterno) ------- */
  function reconfigureAfterYearChange(){
    try{
      const yearInput=$('#year'); if(yearInput) yearInput.value=state.year;
      save.selName = selectionsFileName();
      save.logName = 'planny_log_'+state.year+'.txt';
      loadHolidaysFromLocalOrWeb().then(()=>{
        renderAndJumpToToday();
        appendLogsToServer({force:true});
      });
    }catch(e){
      log('Errore reconfigureAfterYearChange: '+(e.message||e),'warn');
    }
  }
  // API attesa dallo script esterno: proviamo a mappare a questa funzione
  window.renderCalendar = reconfigureAfterYearChange;

  /* ------- Tabs / Oggi ------- */
  function buildTabs(){
    const tabs=$('#tabs'); tabs.innerHTML='';
    const today=new Date();
    const currentMonth = (today.getFullYear()===state.year) ? (today.getMonth()+1) : 1;
    months.forEach((m,i)=>{
      const monthIndex=i+1;
      const b=document.createElement('button');
      b.className='tab'+(monthIndex===currentMonth?' active':'');
      b.textContent=m; b.dataset.m=monthIndex;
      b.onclick=()=>{ renderStack(monthIndex); };
      tabs.appendChild(b);
    });
  }
  function jumpToToday(){
    const today=new Date();
    let m = today.getMonth()+1;
    if(today.getFullYear()!==state.year){
      state.year = today.getFullYear();
      const yearInput=$('#year'); if(yearInput) yearInput.value=state.year;
      log('Anno calendario riallineato a quello corrente: '+state.year,'warn');
      loadHolidaysFromLocalOrWeb().then(()=>{
        renderStack(m);
        const tr=document.querySelector('tr[data-date="'+fmt(today)+'"]');
        if(tr){ tr.classList.add('today'); document.querySelector('#month').scrollTo({top: Math.max(0, (tr.offsetTop - (document.querySelector('#thead')?Math.round(document.querySelector('#thead').getBoundingClientRect().height):0))), behavior:'smooth'}); setActiveTab(m); }
      });
      return;
    }
    renderStack(m);
    const tr=document.querySelector('tr[data-date="'+fmt(today)+'"]');
    if(tr){ tr.classList.add('today'); document.querySelector('#month').scrollTo({top: Math.max(0, (tr.offsetTop - (document.querySelector('#thead')?Math.round(document.querySelector('#thead').getBoundingClientRect().height):0))), behavior:'smooth'}); setActiveTab(m); log('Salto a oggi: '+fmt(today),'ok'); }
  }
  function renderAndJumpToToday(){
    const today=new Date(); const sameYear = today.getFullYear()===state.year;
    buildTabs(); renderStack(sameYear?(today.getMonth()+1):1); setupScrollHandlers();
    if(sameYear){
  const tr=document.querySelector('tr[data-date="'+fmt(today)+'"]');
  if(tr){
    tr.classList.add('today');
    const c=document.getElementById('month');
    const head=document.getElementById('thead');
    const headH = head ? Math.round(head.getBoundingClientRect().height) : 0;
    c.scrollTop = Math.max(0, tr.offsetTop - headH - 4);
    setActiveTab(today.getMonth()+1);
  }
}
  }

  // Espongo importer selections per year_single_selector.js

  /* ------- AutoSave ------- */
  /* ------- SAVE STATE (coalescing) ------- */
let __saveInFlight = false;
let __saveQueued = false;
let __saveTimer = null;
window.logFlushCursor = (window.logFlushCursor ?? 0);
window.logBuffer = (window.logBuffer ?? []);

function normSelectionsText(s){
  return String(s||'')
    .replace(/\r\n/g, '\n')      // CRLF -> LF
    .replace(/[ \t]+$/gm, '')    // spazi a fine riga
    .trim();
}

/* ------- AutoSave (debounce + coalescing) ------- */
async function saveNow(){
  try{
    await saveSelectionsToServer();
    await appendLogsToServer();
  }catch(e){
    log('Errore saveNow: '+(e && e.message || e), 'warn');
  }
}

function scheduleAutoSave(delayMs = 800){
  if (__saveTimer) return; // giÃ  pianificato
  __saveTimer = setTimeout(async ()=>{
    __saveTimer = null;
    await saveSelectionsToServer();
    await appendLogsToServer();
  }, delayMs);
}


  /* ======== SELEZIONE + COPY/PASTE ======== */
  function clearSelection(){
    state.selected.forEach(td=>td.classList.remove('selected'));
    state.selected.clear();
  }
  function addToSelection(td){
    if(!td || !td.classList.contains('cell')) return;
    if(!state.selected.has(td)){ state.selected.add(td); td.classList.add('selected'); }
    state.anchorCell = td;
  }
  function toggleSelection(td){
    if(state.selected.has(td)){ td.classList.remove('selected'); state.selected.delete(td); }
    else addToSelection(td);
  }
  function selectionHandleMouse(td, e){
    if(e.shiftKey && state.anchorCell){
      selectRange(state.anchorCell, td);
    }else if(e.ctrlKey || e.metaKey){
      toggleSelection(td);
    }else{
      clearSelection();
      addToSelection(td);
    }
  }

  // Espongo importer selections per year_single_selector.js
  function selectRange(aTd, bTd){
    if(!aTd || !bTd) return;
    const table = document.getElementById('calendar');
    const aRow = aTd.closest('tr').rowIndex;
    const bRow = bTd.closest('tr').rowIndex;
    const aCol = aTd.cellIndex;
    const bCol = bTd.cellIndex;
    const minR = Math.min(aRow, bRow), maxR = Math.max(aRow, bRow);
    const minC = Math.min(aCol, bCol), maxC = Math.max(aCol, bCol);
    clearSelection();
    for(let r=minR; r<=maxR; r++){
      const row = table.rows[r]; if(!row) continue;
      for(let c=minC; c<=maxC; c++){
        const cell = row.cells[c];
        if(cell && cell.classList.contains('cell')) addToSelection(cell);
      }
    }
  }

  // Espongo importer selections per year_single_selector.js
  window.importSelectionsFromText = importSelectionsFromText;
  function selectionBounds(){
    let minR=Infinity, maxR=-Infinity, minC=Infinity, maxC=-Infinity;
    state.selected.forEach(td=>{
      const r=td.closest('tr').rowIndex, c=td.cellIndex;
      if(r<minR) minR=r; if(r>maxR) maxR=r; if(c<minC) minC=c; if(c>maxC) maxC=c;
    });
    if(minR===Infinity) return null;
    return {minR,maxR,minC,maxC};
  }
  state._dragSelecting = false;
  document.addEventListener('mousedown', (e)=>{
    if(e.button!==0) return;
    const td = e.target.closest('td.cell');
    if(!td || e.target.closest('.chip') || td.classList.contains('editing')) return;
    if(e.shiftKey || e.ctrlKey || e.metaKey) return;
    state._dragSelecting = true;
    clearSelection();
    addToSelection(td);
    e.preventDefault();
  });
  document.addEventListener('mouseup', ()=>{ state._dragSelecting=false; });
  document.addEventListener('mouseleave', ()=>{ state._dragSelecting=false; });
  document.addEventListener('mouseover', (e)=>{
    if(!state._dragSelecting) return;
    const td = e.target.closest && e.target.closest('td.cell');
    if(td) selectRange(state.anchorCell, td);
  });

  function gridFromSelection(){
    const b = selectionBounds(); if(!b) return {grid:[[]], w:0, h:0};
    const table = document.getElementById('calendar');
    const h = b.maxR - b.minR + 1;
    const w = b.maxC - b.minC + 1;
    const grid = Array.from({length:h},()=>Array(w).fill(''));
    for(let r=b.minR; r<=b.maxR; r++){
      const row = table.rows[r];
      for(let c=b.minC; c<=b.maxC; c++){
        const td = row.cells[c];
        if(td && td.classList.contains('cell')){
          const val = (td.querySelector('input').value || '').trim();
          grid[r-b.minR][c-b.minC] = val;
        }
      }
    }
    return {grid,w,h};
  }
  function textFromGrid(grid){ return grid.map(row => row.join('\t')).join('\n'); }
  function gridFromText(text){
    const lines = text.replace(/\r/g,'').split('\n').filter(l=>l.length>0);
    if(!lines.length) return {grid:[['']], w:1, h:1};
    const useTab = lines.some(l=>l.includes('\t'));
    const grid = lines.map(l=> (useTab? l.split('\t') : l.split(',')));
    const w = Math.max(...grid.map(r=>r.length));
    grid.forEach(r=>{ if(r.length<w) r.push(...Array(w-r.length).fill('')); });
    return {grid, w, h:grid.length};
  }
  async function copySelectionToClipboard(){
    if(state.selected.size===0){ log('Nessuna cella selezionata.','warn'); return; }
    const {grid} = gridFromSelection();
    const text = textFromGrid(grid);
    try{
      if(navigator.clipboard?.writeText){ await navigator.clipboard.writeText(text); }
      else{
        const ta=document.createElement('textarea');
        ta.value=text; ta.style.position='fixed'; ta.style.opacity='0'; document.body.appendChild(ta);
        ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      }
      state.clipboard = {grid, w:grid[0]?.length||1, h:grid.length, text};
      log(`Copiato ${state.clipboard.h}Ã—${state.clipboard.w} dalla selezione`,'ok');
    }catch(err){ log('Copia non riuscita: '+err.message,'warn'); }
  }
  async function pasteFromClipboardAt(startTd){
    let txt='';
    try{ if(navigator.clipboard?.readText) txt = await navigator.clipboard.readText(); }catch(e){}
    if(!txt){
      const manual = prompt('Incolla qui il contenuto, poi premi OK:','');
      if(manual==null) return;
      txt = manual;
    }
    const payload = gridFromText(txt);
    pasteGridAt(startTd, payload.grid);
  }
  function pasteGridAt(startTd, grid){
    if(!startTd) return;
    const table = document.getElementById('calendar');
    const startR = startTd.closest('tr').rowIndex;
    const startC = startTd.cellIndex;

    if(state.selected.size>1 && grid.length===1 && grid[0].length===1){
      const v = grid[0][0];
      state.selected.forEach(td => writeCell(td, v));
      log(`Incollato valore in ${state.selected.size} celle`,'ok');
      if(state.search.q) buildSearchHits(state.search.q);
      return;
    }

    let count=0;
    for(let r=0; r<grid.length; r++){
      const row = table.rows[startR + r]; if(!row) break;
      for(let c=0; c<grid[r].length; c++){
        const td = row.cells[startC + c]; if(!td || !td.classList.contains('cell')) break;
        writeCell(td, grid[r][c]); count++;
      }
    }
    log(`Incollato blocco ${grid.length}Ã—${grid[0].length} (celle aggiornate: ${count})`,'ok');
    if(state.search.q) buildSearchHits(state.search.q);
  }

  document.addEventListener('copy', (e)=>{
    const active = document.activeElement;
    if(active && active.tagName==='INPUT' && active.closest('.cell.editing')) return;
    if(state.selected.size===0) return;
    const {grid} = gridFromSelection();
    const text = textFromGrid(grid);
    try{
      e.clipboardData.setData('text/plain', text);
      e.preventDefault();
      state.clipboard = {grid, w:grid[0]?.length||1, h:grid.length, text};
      log(`Copiato ${state.clipboard.h}Ã—${state.clipboard.w} dalla selezione`,'ok');
    }catch(err){ log('Copia non riuscita: '+err.message,'warn'); }
  });

  
// Chiudi l'editing quando si clicca altrove
document.addEventListener('mousedown', (e)=>{
  if(!e.target.closest('.cell.editing')){
    closeAllEditingExcept(null);
  }
}, true);
document.addEventListener('keydown', (e)=>{
    const active = document.activeElement;
    const isFormEl = active && (active.tagName==='INPUT' || active.tagName==='TEXTAREA' || active.isContentEditable);
    const inCellEditing = isFormEl && active.closest('.cell.editing');
    if(isFormEl && !inCellEditing){ return; }
    const inEditing = active && active.tagName==='INPUT' && active.closest('.cell.editing');

    // COPY
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='c'){
      if(inEditing && state.selected.size<=1) return;
      e.preventDefault();
      copySelectionToClipboard();
      return;
    }

    // PASTE
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='v'){
      if(inEditing && state.selected.size<=1) return;
      e.preventDefault();
      const b = selectionBounds();
      let startTd = null;
      if(b){
        const table = document.getElementById('calendar');
        startTd = table.rows[b.minR].cells[b.minC];
      }else if(state.anchorCell){ startTd = state.anchorCell; }
      else { log('Seleziona una cella dove incollare.','warn'); return; }
      pasteFromClipboardAt(startTd);
      return;
    }

    // DELETE / BACKSPACE
    if((e.key==='Delete' || e.key==='Backspace') && !inEditing){
      if(state.selected.size){
        e.preventDefault();
        state.selected.forEach(td=> writeCell(td, ''));
        log(`Cancellate ${state.selected.size} celle`,'ok');
        if(state.search.q) buildSearchHits(state.search.q);
      }
    }
    // START EDITING
    if(!inEditing && !isFormEl){
      const td = state.anchorCell || (state.selected.size ? Array.from(state.selected)[0] : null);
      if(td && td.classList.contains('cell')){
        const key = e.key;
        const isPrintable = key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey;
        const isF2 = key === 'F2';
        if(isPrintable || isF2){
		  e.preventDefault();
		  enterEdit(td, isPrintable ? e.key : null);
		  return;
		}
      }
    }

    // Close context menu on ESC
    if(e.key === 'Escape'){ hideCtx(); }
  });

  document.addEventListener('paste', (e)=>{
    const active = document.activeElement;
    const isFormEl = active && (active.tagName==='INPUT' || active.tagName==='TEXTAREA' || active.isContentEditable);
    const inCellEditing = isFormEl && active.closest('.cell.editing');
    if(isFormEl && !inCellEditing){ return; }
    const inEditing = active && active.tagName==='INPUT' && active.closest('.cell.editing');
    const multiSel = state.selected.size>1;
    if(inEditing && !multiSel){
      return;
    }
    e.preventDefault();
    const txt = e.clipboardData.getData('text/plain') || '';
    if(!txt){ log('Niente da incollare.','warn'); return; }

    const payload = gridFromText(txt);
    const b = selectionBounds();
    let startTd = null;
    if(b){
      const table = document.getElementById('calendar');
      startTd = table.rows[b.minR].cells[b.minC];
    }else if(state.anchorCell){ startTd = state.anchorCell; }
    else { log('Seleziona una cella dove incollare.','warn'); return; }
    pasteGridAt(startTd, payload.grid);
  });

  /* ======== CONTEXT MENU ======== */
  const ctx = document.getElementById('ctx');
  function showCtx(x,y){
  ctx.removeAttribute('inert');
  ctx.style.display = 'block';
  ctx.setAttribute('aria-hidden','false');
  ctx.querySelector('.itm')?.focus();
}

function hideCtx(){
  if (ctx.contains(document.activeElement)) {
    document.activeElement.blur();
    (state.anchorCell?.querySelector('input') || document.body).focus();
  }
  ctx.setAttribute('inert','');
  ctx.style.display = 'none';
  ctx.setAttribute('aria-hidden','true');
  state.ctxTarget = null;
}

    document.addEventListener('contextmenu', (e)=>{
  // niente menu se stai editando un input
  const inInput = e.target.closest?.('.cell.editing input');
  if (inInput) return;

  // consenti menu SOLO se il target Ã¨ un chip visibile
  const chip = e.target.closest?.('.chip:not(.hidden)');
  if (!chip) { hideCtx(); return; }

  const td = chip.closest('td.cell');
  if (!td) { hideCtx(); return; }

  e.preventDefault();

  // assicurati che la cella del chip sia selezionata
  if (!state.selected.size || !state.selected.has(td)) {
    clearSelection();
    addToSelection(td);
  }
  state.ctxTarget = td;

  // posiziona il menu
  const rect = document.body.getBoundingClientRect();
  const px = Math.min(e.clientX, rect.width - 200);
  const py = Math.min(e.clientY, rect.height - 10);
  showCtx(px, py);
});


  document.addEventListener('click', (e)=>{ if(!e.target.closest('#ctx')) hideCtx(); });
  document.addEventListener('scroll', hideCtx, true);
  window.addEventListener('blur', hideCtx);
  ctx.addEventListener('keydown', (e)=>{
    const items = Array.from(ctx.querySelectorAll('.itm'));
    let idx = items.indexOf(document.activeElement);
    if(e.key==='ArrowDown'){ e.preventDefault(); items[(idx+1+items.length)%items.length]?.focus(); }
    if(e.key==='ArrowUp'){ e.preventDefault(); items[(idx-1+items.length)%items.length]?.focus(); }
    if(e.key==='Escape'){ e.preventDefault(); hideCtx(); }
    if(e.key==='Enter' || e.key===' '){ e.preventDefault(); document.activeElement?.click(); }
  });

  ctx.addEventListener('click', async (e)=>{
    const it = e.target.closest('.itm'); if(!it) return;
    const cmd = it.dataset.cmd;
    hideCtx();
    if(cmd==='copy'){ copySelectionToClipboard(); }
    else if(cmd==='paste'){
      const startTd = state.ctxTarget || state.anchorCell;
      if(!startTd){ log('Seleziona una cella dove incollare.','warn'); return; }
      await pasteFromClipboardAt(startTd);
    }
    else if(cmd==='clear'){
      if(state.selected.size){
        state.selected.forEach(td => writeCell(td, ''));
        if(state.search.q) buildSearchHits(state.search.q);
        log('Celle cancellate.','cell'); saveNow();
      }else if(state.ctxTarget){
        writeCell(state.ctxTarget,''); if(state.search.q) buildSearchHits(state.search.q);
      }
    }
  });

  /* ======== SEARCH ======== */
  const qEl = document.getElementById('search-q');
  const prevBtn = document.getElementById('search-prev');
  const nextBtn = document.getElementById('search-next');
  const countEl = document.getElementById('search-count');
  function updateSearchCount(){
    const n = state.search.hits.length, i = state.search.idx>=0 ? (state.search.idx+1) : 0;
    countEl.textContent = `${i}/${n}`;
  }
  function clearSearchHighlights(){
    document.querySelectorAll('.cell.search-hit').forEach(el=>el.classList.remove('search-hit'));
  }
  function buildSearchHits(qRaw){
    const q=(qRaw||'').trim().toLowerCase();
    state.search.q=q; state.search.hits=[]; state.search.idx=-1;
    clearSearchHighlights();
    if(!q){ updateSearchCount(); return; }

    const rawHits=[];
    for(const [k,v] of state.selections.entries()){
      const text=(v||'').toLowerCase();
      if(text.includes(q)){
        const [dateStr,name=''] = k.split(',');
        const [dd,mm,yy] = dateStr.split('-').map(n=>parseInt(n,10));
        const ymd = yy*10000 + mm*100 + dd;
        rawHits.push({ key:k, month:mm, dateStr, name, ymd });
      }
    }
    if(!rawHits.length){ updateSearchCount(); return; }

    rawHits.sort((a,b)=> a.ymd - b.ymd || a.name.localeCompare(b.name));

    const now = new Date();
    const anchorYMD = state.year*10000 + (now.getMonth()+1)*100 + now.getDate();

    let startIdx = rawHits.findIndex(h => h.ymd > anchorYMD);
    if(startIdx === -1) startIdx = 0;

    state.search.hits = rawHits.map(h=>({key:h.key, month:h.month, dateStr:h.dateStr, name:h.name, ymd:h.ymd}));
    state.search.idx = (startIdx - 1 + state.search.hits.length) % state.search.hits.length;

    updateSearchCount();
  }
  function gotoSearch(dir){
    const H=state.search.hits; if(!H.length){ return; }
    state.search.idx = ( (state.search.idx + dir) % H.length + H.length ) % H.length;
    const hit = H[state.search.idx];

    if(state.stackTop==null){ renderStack(hit.month); }
    else{
      let guard=0;
      while(hit.month < state.stackTop && guard++<24){ ensurePrevMonth(); }
      while(hit.month > state.stackBottom && guard++<24){ ensureNextMonth(); }
    }

    const td=document.querySelector('td.cell[data-key="'+cssEscape(hit.key)+'"]');
    if(td){
      document.querySelectorAll('.cell.search-hit').forEach(el=>el.classList.remove('search-hit'));
      td.classList.add('search-hit');
      const c=document.getElementById('month');
      const tr=td.closest('tr');
      const head=document.querySelector('#thead');
      const headH = head ? Math.round(head.getBoundingClientRect().height) : 0;
      const target = tr ? (tr.offsetTop - headH) : 0;
      c.scrollTo({top: Math.max(0, target), behavior:'smooth'});
      clearSelection(); addToSelection(td);
      updateSearchCount();
    }else{
      log('Risultato non visibile, riprovoâ€¦','warn');
      setTimeout(()=>gotoSearch(0),50);
    }
  }

  qEl.addEventListener('input', ()=> buildSearchHits(qEl.value));
  qEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); gotoSearch(+1); } });
  prevBtn.addEventListener('click', ()=> gotoSearch(-1));
  nextBtn.addEventListener('click', ()=> gotoSearch(+1));

  /* ------- Autoload ------- */
  async function autoLoad(){
  log('Autoloadâ€¦','info');
  if(location.protocol==='file:') log('Aperto via file:// â€“ usa il server Flask per salvataggi automatici.','warn');

  try{
    const yearEl = $('#year');
    const namesEl = $('#names');
    const optsEl  = $('#options');

    // 1) leggi config.ini (se presente)
    const cfgTxt = await getTextFromServer('config.ini').catch(()=> '');
    let iniYear = null, iniNames = '', iniOpts = '';
    if (cfgTxt){
      const ini = parseIni(cfgTxt);
      iniYear  = ini['Anno']?.['year'] ? parseInt(ini['Anno']['year'],10) : (parseYearFromConfigTxt(cfgTxt)||null);
      iniNames = ini['Team']?.['names']    || '';
      iniOpts  = ini['Linac']?.['options'] || '';
      if (yearEl)  yearEl.value  = iniYear || '';
      if (namesEl) namesEl.value = iniNames;
      if (optsEl)  optsEl.value  = iniOpts;
    }

    // 2) imposta lo stato (senza assumere esistenza degli input)
    state.year    = iniYear ?? (yearEl?.value ? parseInt(yearEl.value,10) : (new Date().getFullYear()+1));
    state.names   = (namesEl?.value || iniNames || '').split(',').map(s=>s.trim()).filter(Boolean);
    state.options = (optsEl?.value  || iniOpts  || '').split(',').map(s=>s.trim()).filter(Boolean);

    // 3) popola datalist opzioni
    const dl = $('#options-list'); 
    if (dl){ dl.innerHTML=''; state.options.forEach(v=>{ const o=document.createElement('option'); o.value=v.trim(); dl.appendChild(o); }); }

    // 4) prosegui come prima
    await loadHolidaysFromLocalOrWeb();

    const selName = selectionsFileName();
    const selTxt = await getTextFromServer(selName).catch(()=> '');
    if(selTxt){ importSelectionsFromText(selTxt); log('Caricato '+selName,'ok'); }
    else { log('Nessun selections trovato su server: '+selName,'warn'); }

    save.selName = selName;
    save.logName = 'planny_log_'+state.year+'.txt';

    try { await appendLogsToServer({force:true}); } catch(e){ log('Impossibile creare/aggiornare il log: '+e.message,'warn'); }

    renderAndJumpToToday();

  }catch(e){
    log('Errore in autoload: '+e.message,'err');
  }
}


  document.getElementById('jump-today').addEventListener('click', jumpToToday);

  // init
  autoLoad();

  // Ascolto eventi dal selettore anno esterno
  try{
    document.addEventListener('planner:reload', reconfigureAfterYearChange);
    window.addEventListener('planner:year-changed', reconfigureAfterYearChange);
  }catch(_){}

})();</script>



<!-- ==== Planny Cloud Year Selector + Cloud Adapter (non-invasivo) ==== -->
<style>
  #cloud-year-box{display:flex;gap:6px;align-items:center;margin:6px 8px}
  #cloud-year-box label{opacity:.8;font-size:12px}
  #cloud-year-box select{padding:4px 8px;border-radius:6px;border:1px solid #c8ced8}
  #cloud-year-badge{font:12px monospace;opacity:.7}
</style>
<script>
(function(){
  const API = '/api/files/public/';
  const CFG = ['config.ini'];
  const bust = () => '?ts=' + Date.now();
  const fname = y => `selections_${String(y).trim()}.txt`;

  async function apiGet(n){
    const r = await fetch(API + encodeURIComponent(n) + bust(), { cache:'no-store' });
    if (r.status === 404) return null;
    if (!r.ok) throw new Error('GET '+n+' â†’ '+r.status);
    return await r.text();
  }
  async function apiPut(n, txt){
    const r = await fetch(API + encodeURIComponent(n), { method:'PUT', body: txt ?? '' });
    if (!r.ok) throw new Error('PUT '+n+' â†’ '+r.status);
    try { return await r.json(); } catch { return { ok:true }; }
  }

  window.Cloud = {
    async readSelections(year){ const t = await apiGet(fname(year)); return t ?? ''; },
    async saveSelections(year, text){ return await apiPut(fname(year), text || ''); },
    async readConfig(){
      for (const n of CFG){ const t = await apiGet(n); if (t!==null) return {name:n,text:t}; }
      return { name: CFG[0], text: '' };
    },
    async saveConfig(text, name){
      const n = name || (window.Cloud && window.Cloud._lastCfgName) || CFG[0];
      window.Cloud._lastCfgName = n;
      return await apiPut(n, text || '');
    }
  };

  function parseIniYears(txt){
    const m = (txt||'').match(/^\s*anni\s*=\s*([0-9,\s]+)\s*$/im);
    if(!m) return null;
    return m[1].split(',').map(s=>s.trim()).filter(Boolean).map(Number);
  }

  function installYearSelector(years){
    if (document.getElementById('cloud-year-select')) return;
    let host = document.querySelector('#toolbar, .toolbar, header, .topbar, .controls');
    if (!host) host = document.body.firstElementChild || document.body;

    const box = document.createElement('div');
    box.id = 'cloud-year-box';
    const label = document.createElement('label');
    label.textContent = 'Anno';
    label.htmlFor = 'cloud-year-select';
    const sel = document.createElement('select');
    sel.id = 'cloud-year-select';
    const badge = document.createElement('span');
    badge.id = 'cloud-year-badge';
    badge.style.marginLeft = '6px';

    box.appendChild(label); box.appendChild(sel); box.appendChild(badge);
    host.insertBefore(box, host.firstChild);

    const now = new Date().getFullYear();
    const list = (years && years.length ? years : [now-1, now, now+1, now+2]);
    sel.innerHTML = list.map(y=>`<option value="${y}">${y}</option>`).join('');

    const saved = localStorage.getItem('plannyYear');
    const target = (saved && list.includes(+saved)) ? +saved :
                   (window.state && window.state.year && list.includes(+window.state.year) ? +window.state.year : now);
    sel.value = String(target);
    localStorage.setItem('plannyYear', sel.value);
    window.state = window.state || {}; window.state.year = +sel.value;
    badge.textContent = fname(sel.value);

    sel.addEventListener('change', async () => {
      window.state.year = +sel.value;
      localStorage.setItem('plannyYear', sel.value);
      badge.textContent = fname(sel.value);
      await reloadSelectionsFromCloud();
    });
  }

  window.saveSelectionsToCloud = async function(){
    const y = window.state?.year || new Date().getFullYear();
    let text = '';
    try{ if (typeof window.selectionsToText === 'function') text = window.selectionsToText(); }catch{}
    await window.Cloud.saveSelections(y, text);
    console.log('[Cloud] Salvato selections_'+y+'.txt');
  };

  window.reloadSelectionsFromCloud = async function(){
    const y = window.state?.year || new Date().getFullYear();
    const txt = await window.Cloud.readSelections(y);
    if (typeof window.importSelectionsFromText === 'function') window.importSelectionsFromText(txt || '');
    if (typeof window.renderCalendar === 'function') window.renderCalendar();
    console.log('[Cloud] Ricaricato selections_'+y+'.txt');
  };

  async function boot(){
    window.state = window.state || {};
    if (!window.state.year) {
      const saved = localStorage.getItem('plannyYear');
      window.state.year = saved ? +saved : (new Date().getFullYear());
    }
    let yearsFromCfg = null;
    try{
      const {name,text} = await window.Cloud.readConfig();
      window.Cloud._lastCfgName = name;
      if (typeof window.applyConfigFromText === 'function') { try{ window.applyConfigFromText(text); }catch{} }
      yearsFromCfg = parseIniYears(text);
    }catch{}

    installYearSelector(yearsFromCfg);

    try{
      const txt = await window.Cloud.readSelections(window.state.year);
      if (typeof window.importSelectionsFromText === 'function') window.importSelectionsFromText(txt || '');
      if (typeof window.renderCalendar === 'function') window.renderCalendar();
    }catch(e){ console.warn('Cloud bootstrap error:', e); }
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>
<!-- ==== /Year Selector + Cloud Adapter ==== -->
<script>
/* ============================== 
   SaveTracker v3 (esplicito)
   - stati: pending (ðŸŸ ), ok (ðŸŸ¢), error (ðŸ”´)
   - tiene conto di: debounce (__saveTimer), coalescing (__saveInFlight/__saveQueued)
   - conta SOLO i salvataggi che indichiamo (selections/log)
   ============================== */
(function(){
  const badge = document.createElement('div');
  badge.id = 'save-indicator';
  badge.style.cssText = `
    position: fixed; top:10px; right:14px; z-index:9999;
    padding:8px 14px; border-radius:12px; font-weight:600;
    font-family: system-ui, sans-serif; box-shadow:0 2px 8px rgba(0,0,0,0.15);
    background:#14532d; color:#dcfce7; transition: background .2s, color .2s, opacity .2s; opacity:.95; pointer-events:none;
  `;
  badge.textContent = 'ðŸŸ¢ Tutto salvato';
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ()=>document.body.appendChild(badge));
  else document.body.appendChild(badge);

  const SaveTracker = {
    pending: new Set(),
    lastError: null,
    start(id){ this.pending.add(id); this.lastError=null; this.render(); },
    ok(id){ this.pending.delete(id); this.render(); },
    fail(id, err){ this.lastError = err || 'Errore salvataggio'; this.pending.delete(id); this.render(true); },
    isWaiting(){
      const debounce = !!(window.__saveTimer);
      const inFlight = !!(window.__saveInFlight);
      const queued   = !!(window.__saveQueued);
      return debounce || inFlight || queued;
    },
    render(forceError){
      if (forceError || this.lastError){
        badge.textContent = 'ðŸ”´ Errore salvataggio';
        badge.style.background = '#7f1d1d';
        badge.style.color = '#fee2e2';
        return;
      }
      if (this.pending.size > 0 || this.isWaiting()){
        badge.textContent = 'ðŸŸ  Salvataggio in corso...';
        badge.style.background = '#b45309';
        badge.style.color = '#fff7ed';
      } else {
        badge.textContent = 'ðŸŸ¢ Tutto salvato';
        badge.style.background = '#14532d';
        badge.style.color = '#dcfce7';
      }
    }
  };

  setInterval(()=> SaveTracker.render(), 200);

  window.addEventListener('beforeunload', (e)=>{
    if (SaveTracker.pending.size > 0 || SaveTracker.isWaiting()){
      const msg = 'Sono in corso salvataggi. Attendere prima di chiudere o ricaricare.';
      e.preventDefault(); e.returnValue = msg; return msg;
    }
  });

  window.__SaveTracker = SaveTracker;
})();
</script>
<script>
async function apiMe(){
  const r = await fetch('/me', {credentials:'same-origin'});
  return r.ok ? r.json() : {ok:false};
}
async function apiLogin(username, password){
  const r = await fetch('/login', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    credentials:'same-origin',
    body: JSON.stringify({username, password})
  });
  return r.json();
}
async function apiLogout(){
  const r = await fetch('/logout', {method:'POST', credentials:'same-origin'});
  return r.json();
}

// abilita/disabilita (se li hai) bottoni di salvataggio
function setWriteEnabled(canWrite){
  window.__canWrite = !!canWrite;
  const saveButtons = document.querySelectorAll('[data-role="save"], .btn-save, #btnSave, #btnSaveFestivi, #btnSaveSelections');
  saveButtons.forEach(b => b && (b.disabled = !canWrite));
}

// wrapper per intercettare 401/403 sulle PUT
async function guardedFetch(url, opts){
  const res = await fetch(url, {...opts, credentials:'same-origin'});
  if (res.status === 401){
    alert('Devi effettuare il login per salvare.');
  } else if (res.status === 403){
    alert('Non hai i permessi per salvare (solo admin puÃ² scrivere).');
  }
  return res;
}

// barra login/logout
async function refreshAuthBar(){
  try {
    const me = await apiMe();
    const s = document.getElementById('auth-status');
    const btnLogin = document.getElementById('btn-login');
    const btnLogout = document.getElementById('btn-logout');
    const canWrite = me && me.ok && me.role === 'write';

    if (me && me.ok && me.user){
      s.textContent = `ðŸ‘‹ ${me.user} (${me.role})`;
      if (btnLogin)  btnLogin.style.display  = 'none';
      if (btnLogout) btnLogout.style.display = 'inline-block';
    } else {
      s.textContent = 'ðŸ‘¤ ospite';
      if (btnLogin)  btnLogin.style.display  = 'inline-block';
      if (btnLogout) btnLogout.style.display = 'none';
    }
    setWriteEnabled(!!canWrite);
  } catch(e){
    console.warn('auth refresh failed', e);
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  const btnLogin = document.getElementById('btn-login');
  const btnLogout = document.getElementById('btn-logout');

  if (btnLogin){
    btnLogin.addEventListener('click', async ()=>{
      const password = prompt('Password admin:');
      if (!password) return;
      const res = await fetch('/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ password })
      });
      const j = await res.json().catch(()=>({ok:false}));
      if (!j.ok){ alert(j.error || 'Login fallito'); return; }
      await refreshAuthBar();
    });
  }

  if (btnLogout){
    btnLogout.addEventListener('click', async ()=>{
      await fetch('/logout', { method:'POST', credentials:'same-origin' });
      await refreshAuthBar();
    });
  }

  refreshAuthBar();
});
</script>

</body>
</html>

